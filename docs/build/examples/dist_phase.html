

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Distributed Quantum Phase Estimation Algorithm &mdash; Interlin-q  documentation</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Distributed Quantum Phase Estimation" href="distributed_phase.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Interlin-q
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../install.html">Install</a></li>
<li class="toctree-l1"><a class="reference internal" href="../quick_start.html">Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../design.html">Design Overview</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../components/computing_host.html">Computing Host</a></li>
<li class="toctree-l2"><a class="reference internal" href="../components/controller_host.html">Controller Host</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="../examples.html">Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="distributed_phase.html">Distributed Quantum Phase Estimation</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Distributed Quantum Phase Estimation Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Introduction-of-Interlin-q">Introduction of Interlin-q</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Simulated-Architechture">Simulated Architechture</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Conversion-of-monolithic-to-distributed-circuit">Conversion of monolithic to distributed circuit</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Distributed-Scheduler-and-Broadcasting">Distributed Scheduler and Broadcasting</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Executing-the-distributed-algorithm">Executing the distributed algorithm</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Code-implementation">Code implementation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Step-1:-Import-libraries.">Step 1: Import libraries.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-2:-Create-monolithic-circuit-of-Quantum-Phase-Estimation">Step 2: Create monolithic circuit of Quantum Phase Estimation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-3:-Define-Standard-protocols-for-controller-and-computing-hosts.">Step 3: Define Standard protocols for controller and computing hosts.</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-4:-Provide-inputs">Step 4: Provide inputs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Step-5:-Execute-the-distributed-algorithm-and-analyse-the-results">Step 5: Execute the distributed algorithm and analyse the results</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Interlin-q</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../examples.html">Examples</a> &raquo;</li>
        
          <li><a href="distributed_phase.html">Distributed Quantum Phase Estimation</a> &raquo;</li>
        
      <li>Distributed Quantum Phase Estimation Algorithm</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../_sources/examples/dist_phase.ipynb.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Distributed-Quantum-Phase-Estimation-Algorithm">
<h1>Distributed Quantum Phase Estimation Algorithm<a class="headerlink" href="#Distributed-Quantum-Phase-Estimation-Algorithm" title="Permalink to this headline">¶</a></h1>
<p>Quantum phase estimation is a quantum algorithm which is used to estimate the phase (or eigenvalue) of an eigenvector of a unitary operator. If we consider a unitary matrix <span class="math notranslate nohighlight">\(U\)</span> and a quantum state <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> such that <span class="math notranslate nohighlight">\(U|\psi \rangle =e^{2\pi i\theta }\)</span>, the algorithm estimates the value of <span class="math notranslate nohighlight">\(\theta\)</span> with high probability within additive error <span class="math notranslate nohighlight">\(\varepsilon\)</span>.</p>
<p>The below is the circuit diagram for quantum phase estimation with the Unitary <span class="math notranslate nohighlight">\(U\)</span> and eigenstate <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>.</p>
<p><img alt="alt text" src="../_images/quantum_phase_estimation_diagram.png" /></p>
<p>Here, we will explain the execution of distributed quantum phase estimation algorithm with two computing hosts and one controller host using Interlin-q. We let the first computing host <code class="docutils literal notranslate"><span class="pre">QPU_1</span></code> possess all the qubits which are set in the state <span class="math notranslate nohighlight">\(|0\rangle\)</span> from the above image and the second computing host <code class="docutils literal notranslate"><span class="pre">QPU_2</span></code> would possess the single qubit which is set in the eigenstate <span class="math notranslate nohighlight">\(|\psi\rangle\)</span>.</p>
</div>
<div class="section" id="Introduction-of-Interlin-q">
<h1>Introduction of Interlin-q<a class="headerlink" href="#Introduction-of-Interlin-q" title="Permalink to this headline">¶</a></h1>
<div class="section" id="Simulated-Architechture">
<h2>Simulated Architechture<a class="headerlink" href="#Simulated-Architechture" title="Permalink to this headline">¶</a></h2>
<p>The simulated architechture of Interlin-q can be seen in the image below:</p>
<p><img alt="image1" src="../_images/simulated_architechture.png" /></p>
<p>The controller host gets the monolithic circuit as an input from the client, converts it to a distributed circuit and generates schedules from it for individual computing hosts and broadcasts it to them. The controller host and all the computing hosts share a global clock. When the computing hosts receive the broadcast, they extract their schedule from it and perform the operations in the schedules according to the global clock and the timestamps on the operations. The final results are sent
over to the controller host from all the computing hosts for further processing.</p>
</div>
<div class="section" id="Conversion-of-monolithic-to-distributed-circuit">
<h2>Conversion of monolithic to distributed circuit<a class="headerlink" href="#Conversion-of-monolithic-to-distributed-circuit" title="Permalink to this headline">¶</a></h2>
<p>The monolithic circuit is a circuit which is designed to be implemented by a single quantum computer. To implement this same algorithm using multiple interlinked quantum computers, this monolithic circuit needs to be converted to a distributed circuit over a given topology of the interlinked quantum computers.</p>
<p>This distribution is performed by the controller host, by analysing the input monolithic circuit and searching for any control gates where the control and target qubits lie in separate computing host. If any such control gate is found, it is replaced by using a Cat-circuit shown in the image below. The controller host generates the distributed circuit by replacing all such control gates.</p>
<p><img alt="image2" src="../_images/cat-circuit.png" /></p>
<p>Here the quantum state <span class="math notranslate nohighlight">\(|\psi_1\rangle\)</span> lies with the first computing host and the quantum state <span class="math notranslate nohighlight">\(|\psi_2\rangle\)</span> lies with the second computing host. A control gate with <span class="math notranslate nohighlight">\(|\psi_1\rangle\)</span> as control qubit and <span class="math notranslate nohighlight">\(|\psi_2\rangle\)</span> as the target qubit is replaced with the circuit shown, which implement a non-local control gate. It is necessary for both the computing hosts to share an EPR pair.</p>
</div>
<div class="section" id="Distributed-Scheduler-and-Broadcasting">
<h2>Distributed Scheduler and Broadcasting<a class="headerlink" href="#Distributed-Scheduler-and-Broadcasting" title="Permalink to this headline">¶</a></h2>
<p>The controller host forms a distributed schedule of operations according to timestamps for individual computing hosts using the distributed circuit. The operations are timestamped after considering the amount of time the operation would take to be performed on the specific computing hosts. These operations are then broadcasted to all the computing hosts.</p>
</div>
<div class="section" id="Executing-the-distributed-algorithm">
<h2>Executing the distributed algorithm<a class="headerlink" href="#Executing-the-distributed-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The computings hosts receive the broadcasted schedules and extract their schedule from it. The controller hosts and all the computing hosts share a Clock object, which enable them to perform operations according to the schedule in synchronization. Once the operations are performed, and resulting error or successful measurements are reported back to the controller host, who further processes the output for the client.</p>
</div>
</div>
<div class="section" id="Code-implementation">
<h1>Code implementation<a class="headerlink" href="#Code-implementation" title="Permalink to this headline">¶</a></h1>
<p>Now we discuss how to implement distributed quantum phase estimation algorithm using Interlin-q</p>
<div class="section" id="Step-1:-Import-libraries.">
<h2>Step 1: Import libraries.<a class="headerlink" href="#Step-1:-Import-libraries." title="Permalink to this headline">¶</a></h2>
<p>First we import all the necessary libraries. Interlin-q is build using the python framework <a class="reference external" href="https://arxiv.org/abs/2003.06397">QuNetSim</a> which is a python software framework that can be used to simulate quantum networks up to the network layer.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;../&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">qunetsim.components</span> <span class="kn">import</span> <span class="n">Network</span>
<span class="kn">from</span> <span class="nn">qunetsim.objects</span> <span class="kn">import</span> <span class="n">Logger</span>

<span class="kn">from</span> <span class="nn">interlinq</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ControllerHost</span><span class="p">,</span> <span class="n">Constants</span><span class="p">,</span> <span class="n">Clock</span><span class="p">,</span>
<span class="n">Circuit</span><span class="p">,</span> <span class="n">Layer</span><span class="p">,</span> <span class="n">ComputingHost</span><span class="p">,</span> <span class="n">Operation</span><span class="p">)</span>

<span class="n">Logger</span><span class="o">.</span><span class="n">DISABLED</span> <span class="o">=</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Step-2:-Create-monolithic-circuit-of-Quantum-Phase-Estimation">
<h2>Step 2: Create monolithic circuit of Quantum Phase Estimation<a class="headerlink" href="#Step-2:-Create-monolithic-circuit-of-Quantum-Phase-Estimation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="Instructions-on-creating-a-circuit">
<h3>Instructions on creating a circuit<a class="headerlink" href="#Instructions-on-creating-a-circuit" title="Permalink to this headline">¶</a></h3>
<p>The below are the functions used to create a monolithic circuit in Interlin-q framework, which will act as the client input. <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> objects in Interlin-q are constructed from different <code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects, where every layers contains <code class="docutils literal notranslate"><span class="pre">Operation</span></code> objects which are to be performed together.</p>
<div class="section" id="1.-Operations">
<h4>1. Operations<a class="headerlink" href="#1.-Operations" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">Operation</span></code> objects are commands which instruct the computing hosts regarding the operations to be executed. The different types of <code class="docutils literal notranslate"><span class="pre">Operation</span></code> objects are <code class="docutils literal notranslate"><span class="pre">PREPARE_QUBITS</span></code>, <code class="docutils literal notranslate"><span class="pre">SINGLE</span></code>, <code class="docutils literal notranslate"><span class="pre">TWO_QUBIT</span></code>, <code class="docutils literal notranslate"><span class="pre">CLASSICAL_CTRL_GATE</span></code>, <code class="docutils literal notranslate"><span class="pre">MEASURE</span></code>, <code class="docutils literal notranslate"><span class="pre">SEND_ENT</span></code>, <code class="docutils literal notranslate"><span class="pre">REC_ENT</span></code>, <code class="docutils literal notranslate"><span class="pre">SEND_CLASSICAL</span></code> and <code class="docutils literal notranslate"><span class="pre">REC_CLASSICAL</span></code>.</p>
<p>A sample operation to implement a <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> gate across one computing host is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">TWO_QUBIT</span><span class="p">,</span>
    <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">control_qubit_id</span><span class="p">,</span> <span class="n">target_qubit_id</span><span class="p">],</span>
    <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">CNOT</span><span class="p">,</span>
    <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_id</span><span class="p">])</span>
</pre></div>
</div>
<p>A sample operation to implement a <code class="docutils literal notranslate"><span class="pre">CNOT</span></code> gate across two computing host is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">TWO_QUBIT</span><span class="p">,</span>
    <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">control_qubit_id</span><span class="p">,</span> <span class="n">target_qubit_id</span><span class="p">],</span>
    <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">CNOT</span><span class="p">,</span>
    <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_id_1</span><span class="p">,</span> <span class="n">computing_host_id_2</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="2.-Layers">
<h4>2. Layers<a class="headerlink" href="#2.-Layers" title="Permalink to this headline">¶</a></h4>
<p>Layers are composed of multiple operations which are to be performed across different computing hosts at the same time. A <code class="docutils literal notranslate"><span class="pre">Layer</span></code> object that would consist of <code class="docutils literal notranslate"><span class="pre">Operation</span></code> objects <code class="docutils literal notranslate"><span class="pre">op1</span></code>, <code class="docutils literal notranslate"><span class="pre">op2</span></code> and <code class="docutils literal notranslate"><span class="pre">op3</span></code> can be created using the command below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer_1</span> <span class="o">=</span> <span class="n">Layer</span><span class="p">([</span><span class="n">op1</span><span class="p">,</span> <span class="n">op2</span><span class="p">,</span> <span class="n">op3</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="section" id="3.-Circuit">
<h4>3. Circuit<a class="headerlink" href="#3.-Circuit" title="Permalink to this headline">¶</a></h4>
<p>A <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> object is composed of multiple layers of operations and we also provide the topology of the distributed circuit as an input. A <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> object that would consist of <code class="docutils literal notranslate"><span class="pre">Layer</span></code> objects <code class="docutils literal notranslate"><span class="pre">layer1</span></code>, <code class="docutils literal notranslate"><span class="pre">layer2</span></code> and <code class="docutils literal notranslate"><span class="pre">layer3</span></code> can be created using the command below. In this command, <code class="docutils literal notranslate"><span class="pre">q_map</span></code> is the topology of the distributed circuit, which informs us regarding the computing hosts and the corresponding qubits that are involved in the circuit.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">q_map</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;QPU_1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;q_0_0&#39;</span><span class="p">,</span> <span class="s1">&#39;q_0_1&#39;</span><span class="p">,</span> <span class="s1">&#39;q_0_2&#39;</span><span class="p">,</span> <span class="s1">&#39;q_0_3&#39;</span><span class="p">],</span>
    <span class="s1">&#39;QPU_2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;q_1_0&#39;</span><span class="p">]</span>
    <span class="p">}</span>

<span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">q_map</span><span class="p">,</span> <span class="p">[</span><span class="n">layer1</span><span class="p">,</span> <span class="n">layer2</span><span class="p">,</span> <span class="n">layer3</span><span class="p">])</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Creating-the-circuit-for-Quantum-Phase-Estimation-Algorithm">
<h3>Creating the circuit for Quantum Phase Estimation Algorithm<a class="headerlink" href="#Creating-the-circuit-for-Quantum-Phase-Estimation-Algorithm" title="Permalink to this headline">¶</a></h3>
<p><img alt="alt text" src="../_images/quantum_phase_estimation_diagram.png" /></p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">phase_gate</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">theta</span><span class="p">)]])</span>


<span class="k">def</span> <span class="nf">inverse_quantum_fourier_transform</span><span class="p">(</span><span class="n">q_ids</span><span class="p">,</span> <span class="n">computing_host_ids</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs inverse quantum fourier transform</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">q_ids</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_ids</span><span class="p">)):</span>
        <span class="n">target_qubit_id</span> <span class="o">=</span> <span class="n">q_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">control_qubit_id</span> <span class="o">=</span> <span class="n">q_ids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">TWO_QUBIT</span><span class="p">,</span>
                <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">control_qubit_id</span><span class="p">,</span> <span class="n">target_qubit_id</span><span class="p">],</span>
                <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">CUSTOM_CONTROLLED</span><span class="p">,</span>
                <span class="n">gate_param</span><span class="o">=</span><span class="n">phase_gate</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">)),</span>
                <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">([</span><span class="n">op</span><span class="p">]))</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
            <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">target_qubit_id</span><span class="p">],</span>
            <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">H</span><span class="p">,</span>
            <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">([</span><span class="n">op</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">layers</span>
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">quantum_phase_estimation_circuit</span><span class="p">(</span><span class="n">q_map</span><span class="p">,</span> <span class="n">client_input_gate</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the monolithic circuit for quantum phase estimation</span>
<span class="sd">    algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">computing_host_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">q_map</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Prepare the qubits on both computing hosts</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">host_id</span> <span class="ow">in</span> <span class="n">computing_host_ids</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">PREPARE_QUBITS</span><span class="p">,</span>
            <span class="n">qids</span><span class="o">=</span><span class="n">q_map</span><span class="p">[</span><span class="n">host_id</span><span class="p">],</span>
            <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">host_id</span><span class="p">])</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>

    <span class="c1"># Setup the qubits by apply Hadamard gates on qubits of QPU_1</span>
    <span class="c1"># and applying X gate to initialise qubit on QPU_2</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
            <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">q_id</span><span class="p">],</span>
            <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">H</span><span class="p">,</span>
            <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">SINGLE</span><span class="p">,</span>
        <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],</span>
        <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">X</span><span class="p">,</span>
        <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

    <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>

    <span class="c1"># Apply controlled unitaries</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
        <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">i</span>
        <span class="n">control_qubit_id</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">target_qubit_id</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
            <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">TWO_QUBIT</span><span class="p">,</span>
                <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">control_qubit_id</span><span class="p">,</span> <span class="n">target_qubit_id</span><span class="p">],</span>
                <span class="n">gate</span><span class="o">=</span><span class="n">Operation</span><span class="o">.</span><span class="n">CUSTOM_CONTROLLED</span><span class="p">,</span>
                <span class="n">gate_param</span><span class="o">=</span><span class="n">client_input_gate</span><span class="p">,</span>
                <span class="n">computing_host_ids</span><span class="o">=</span><span class="n">computing_host_ids</span><span class="p">)</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">([</span><span class="n">op</span><span class="p">]))</span>

    <span class="c1"># Inverse Fourier Transform circuit</span>
    <span class="n">q_ids</span> <span class="o">=</span> <span class="n">q_map</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">layers</span> <span class="o">=</span> <span class="n">inverse_quantum_fourier_transform</span><span class="p">(</span>
        <span class="n">q_ids</span><span class="p">,</span>
        <span class="n">computing_host_ids</span><span class="p">,</span>
        <span class="n">layers</span><span class="p">)</span>

    <span class="c1"># Measure the qubits</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">q_id</span> <span class="ow">in</span> <span class="n">q_ids</span><span class="p">:</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">Operation</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">Constants</span><span class="o">.</span><span class="n">MEASURE</span><span class="p">,</span>
            <span class="n">qids</span><span class="o">=</span><span class="p">[</span><span class="n">q_id</span><span class="p">],</span>
            <span class="n">cids</span><span class="o">=</span><span class="p">[</span><span class="n">q_id</span><span class="p">],</span>
            <span class="n">computing_host_ids</span><span class="o">=</span><span class="p">[</span><span class="n">computing_host_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">ops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Layer</span><span class="p">(</span><span class="n">ops</span><span class="p">))</span>

    <span class="n">circuit</span> <span class="o">=</span> <span class="n">Circuit</span><span class="p">(</span><span class="n">q_map</span><span class="p">,</span> <span class="n">layers</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">circuit</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="Step-3:-Define-Standard-protocols-for-controller-and-computing-hosts.">
<h2>Step 3: Define Standard protocols for controller and computing hosts.<a class="headerlink" href="#Step-3:-Define-Standard-protocols-for-controller-and-computing-hosts." title="Permalink to this headline">¶</a></h2>
<p>Here, we defined the standard protocols for the controller and the computing hosts. The controller host gets the monolithic circuit as an input from the client, converts it to a distributed circuit and generates schedules from it for individual computing hosts and broadcasts it to them. The controller host and all the computing hosts share a global clock. When the computing hosts receive the broadcast, they extract their schedule from it and perform it according to the global clock. The final
results are sent over to the controller host from all the computing hosts for further processing.</p>
<div class="section" id="Controller-host">
<h3>Controller host<a class="headerlink" href="#Controller-host" title="Permalink to this headline">¶</a></h3>
<p>For the controller host, the below is the list of functions that are involved in the protocol:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">host.generate_and_send_schedules</span></code>: Here we provide the monolithic <code class="docutils literal notranslate"><span class="pre">Circuit</span></code> object as the input and this function carries the task of created a distributed circuit from the monolithic circuit, creating a distributed schedule for all the computing hosts involved and broadcasting the schedule to all the computing hosts connected to this controller host.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">host.receive_results</span></code>: Here, the controller host waits for the algorithm to be completed on all the computing hosts’s end and then receives the final result from them, which could either be a reported error or successful measurement result.</p></li>
</ul>
<p>Depending on the algorithm, the results received from the computing host can be further processed to provide a final output. In the case of distributed quantum phase estimation algorithm, the final measurement results from the two computing hosts are processed to calculate the phase of the unitary gate.</p>
</div>
<div class="section" id="Computing-host">
<h3>Computing host<a class="headerlink" href="#Computing-host" title="Permalink to this headline">¶</a></h3>
<p>For the computing host, the below is the list of functions that are involved in the protocol:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">host.receive_schedule</span></code>: Here the computing hosts receive the broadcasted schedule from the controller host, extract their individual schedule and starting perform the operations according to the schedule and the shared Clock object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">host.send_results</span></code>: Here, the computing hosts share the final result with the controller host, which could either be a reported error or successful measurement result.</p></li>
</ul>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">controller_host_protocol</span><span class="p">(</span><span class="n">host</span><span class="p">,</span> <span class="n">q_map</span><span class="p">,</span> <span class="n">client_input_gate</span><span class="p">,</span> <span class="n">monolithic_circuit</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Protocol for the controller host</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">host</span><span class="o">.</span><span class="n">generate_and_send_schedules</span><span class="p">(</span><span class="n">monolithic_circuit</span><span class="p">)</span>
    <span class="n">host</span><span class="o">.</span><span class="n">receive_results</span><span class="p">()</span>

    <span class="n">results</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">results</span>
    <span class="n">computing_host_ids</span> <span class="o">=</span> <span class="n">host</span><span class="o">.</span><span class="n">computing_host_ids</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Final results: </span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># This is the final processing perfomed in the controller host where</span>
    <span class="c1"># we take the final measurement results from the computing hosts and</span>
    <span class="c1"># calculate the estimated value of the phase from those results.</span>
    <span class="n">decimal_value</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">computing_host_id</span> <span class="ow">in</span> <span class="n">computing_host_ids</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">computing_host_id</span><span class="p">][</span><span class="s1">&#39;bits&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bit_id</span><span class="p">,</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">: </span><span class="si">{1}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bit_id</span><span class="p">,</span> <span class="n">bit</span><span class="p">))</span>
            <span class="n">decimal_value</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">bit</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">bits</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="n">decimal_value</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">The estimated value of the phase is </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">computing_host_protocol</span><span class="p">(</span><span class="n">host</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Protocol for the computing hosts</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">host</span><span class="o">.</span><span class="n">receive_schedule</span><span class="p">()</span>
    <span class="n">host</span><span class="o">.</span><span class="n">send_results</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="Step-4:-Provide-inputs">
<h2>Step 4: Provide inputs<a class="headerlink" href="#Step-4:-Provide-inputs" title="Permalink to this headline">¶</a></h2>
<p>Here we provide the actual inputs to run the algorithm. First we provide the phase which would be estimated by the algorithm. Next, we set number of qubits per host. The greater number of qubits would provide a closer estimate to the actual answer.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Try phase like 1/8 or 1/3</span>
<span class="n">phase_input</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span>

<span class="c1"># Set number of qubits per host</span>
<span class="n">num_qubits_per_host</span> <span class="o">=</span> <span class="mi">4</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="Step-5:-Execute-the-distributed-algorithm-and-analyse-the-results">
<h2>Step 5: Execute the distributed algorithm and analyse the results<a class="headerlink" href="#Step-5:-Execute-the-distributed-algorithm-and-analyse-the-results" title="Permalink to this headline">¶</a></h2>
<p>Here, we first initiate the Network via QuNetSim as well as initiate all the Hosts required to perform the algorithm.</p>
<p>Once <code class="docutils literal notranslate"><span class="pre">ControllerHost</span></code> object is initiated, the function <code class="docutils literal notranslate"><span class="pre">controller_host.create_distributed_network</span></code> is a template function which is used to initiate <code class="docutils literal notranslate"><span class="pre">ComputingHost</span></code> objects with the provided number of qubits, provide a topology as well as to connect the nodes internally.</p>
<p>We provide the monolithic circuit input to the <code class="docutils literal notranslate"><span class="pre">ControllerHost</span></code> protocol and start running the protocol for the controller hosts and the computing hosts involved.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># initialize network</span>
    <span class="n">network</span> <span class="o">=</span> <span class="n">Network</span><span class="o">.</span><span class="n">get_instance</span><span class="p">()</span>
    <span class="n">network</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">network</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">clock</span> <span class="o">=</span> <span class="n">Clock</span><span class="p">()</span>

    <span class="n">controller_host</span> <span class="o">=</span> <span class="n">ControllerHost</span><span class="p">(</span>
        <span class="n">host_id</span><span class="o">=</span><span class="s2">&quot;host_1&quot;</span><span class="p">,</span>
        <span class="n">clock</span><span class="o">=</span><span class="n">clock</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">computing_hosts</span><span class="p">,</span> <span class="n">q_map</span> <span class="o">=</span> <span class="n">controller_host</span><span class="o">.</span><span class="n">create_distributed_network</span><span class="p">(</span>
        <span class="n">num_computing_hosts</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">num_qubits_per_host</span><span class="o">=</span><span class="n">num_qubits_per_host</span><span class="p">)</span>
    <span class="n">controller_host</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">network</span><span class="o">.</span><span class="n">add_hosts</span><span class="p">([</span>
        <span class="n">computing_hosts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">computing_hosts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">controller_host</span><span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;starting...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;The Actual value of the phase is: </span><span class="si">{0}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">phase_input</span><span class="p">))</span>
    <span class="c1"># For phase = 1/8</span>
    <span class="c1">#client_input_gate = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]])</span>
    <span class="c1"># For phase = 1/3</span>
    <span class="n">client_input_gate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">phase_input</span><span class="p">)]])</span>
    <span class="n">monolithic_circuit</span> <span class="o">=</span> <span class="n">quantum_phase_estimation_circuit</span><span class="p">(</span><span class="n">q_map</span><span class="p">,</span> <span class="n">client_input_gate</span><span class="p">)</span>

    <span class="n">t1</span> <span class="o">=</span> <span class="n">controller_host</span><span class="o">.</span><span class="n">run_protocol</span><span class="p">(</span>
        <span class="n">controller_host_protocol</span><span class="p">,</span>
        <span class="p">(</span><span class="n">q_map</span><span class="p">,</span> <span class="n">client_input_gate</span><span class="p">,</span> <span class="n">monolithic_circuit</span><span class="p">))</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">computing_hosts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">run_protocol</span><span class="p">(</span><span class="n">computing_host_protocol</span><span class="p">)</span>
    <span class="n">t3</span> <span class="o">=</span> <span class="n">computing_hosts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">run_protocol</span><span class="p">(</span><span class="n">computing_host_protocol</span><span class="p">)</span>

    <span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">t3</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">network</span><span class="o">.</span><span class="n">stop</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
starting...

The Actual value of the phase is: 0.2

Final results:

q_0_3: 1
q_0_2: 1
q_0_1: 0
q_0_0: 0

The estimated value of the phase is 0.1875
</pre></div></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Stephen DiAdamo, Rhea Parekh.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>